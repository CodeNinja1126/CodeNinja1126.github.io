I"+<p>문제의 자세한 내용은 링크로 대신한다.</p>

<p><a href="https://programmers.co.kr/learn/courses/30/lessons/42861">문제 링크</a></p>

<h1 id="풀이">풀이</h1>

<p>이 문제는 최소 비용으로 모든 섬을 연결하는 문제이다.</p>

<p>나는 이 문제를 두 가지 방법으로 풀었다.</p>

<p>처음에는 해결이 안되서 다른 사람의 풀이를 참고했다.</p>

<p>Union Find를 사용해서 풀었는데 이 풀이는 링크로 대신한다.</p>

<p><a href="https://velog.io/@diddnjs02/%EC%BD%94%EB%94%A9%ED%85%8C%EC%8A%A4%ED%8A%B8%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-%EC%84%AC-%EC%97%B0%EA%B2%B0%ED%95%98%EA%B8%B0">풀이 링크</a></p>

<p>두 번째로 풀었던 방법은 다음과 같다.</p>

<p>일단 다리의 비용을 기준으로 오름차순으로 정렬한 후, 가장 첫 다리를 무조건 건설한다.</p>

<p>건설하는 과정은 다음과 같다.</p>

<p>그 다리로 연결된 두 섬을 <code class="language-plaintext highlighter-rouge">node</code>벡터에 저장하고, 건설한 다리를 <code class="language-plaintext highlighter-rouge">costs</code>벡터에서 삭제한다.</p>

<p>마지막으로 건설한 다리의 가격을 비용 총합에 더한다.</p>

<p><code class="language-plaintext highlighter-rouge">node</code>벡터는 연결이 된 섬을 저장한다.</p>

<p>즉 <code class="language-plaintext highlighter-rouge">node</code>벡터의 크기가 섬의 개수와 같아지면 모든 섬이 연결이 된 상태이다.</p>

<p>첫 다리를 건설하고 나면 <code class="language-plaintext highlighter-rouge">costs</code>벡터를 처음부터 순회한다.</p>

<p><code class="language-plaintext highlighter-rouge">costs</code>벡터의 원소의 연결된 두 섬이 <code class="language-plaintext highlighter-rouge">node</code>벡터에 존재하는 지 확인한다.</p>

<p>두 섬이 전부 존재하면 이미 연결이 된 두 섬의 다리를 또 건설할 필요가 없으므로 그냥 넘어간다.</p>

<p>두 섬 중에 한 섬만이 <code class="language-plaintext highlighter-rouge">node</code>벡터안에 존재하면 그 다리를 건설한다.</p>

<p>건설이 완료되면 <code class="language-plaintext highlighter-rouge">node</code>벡터의 크기가 섬의 개수와 같아질 때까지 다시 <code class="language-plaintext highlighter-rouge">costs</code>벡터를 처음부터 순회한다.</p>

<h1 id="코드">코드</h1>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>

<span class="kt">bool</span> <span class="nf">cmp</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">b</span><span class="p">){</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">solution</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">costs</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">node</span><span class="p">;</span>
    
    <span class="n">sort</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">costs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">cmp</span><span class="p">);</span>
    <span class="c1">//costs를 가격값을 기준으로 오름차순으로 정렬</span>
    
    <span class="n">node</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">node</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
    <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">costs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="c1">//첫 섬 건설</span>
    
    <span class="k">while</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">){</span>
    <span class="c1">//node의 크기가 섬의 개수랑 같아질 까지</span>
    
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">costs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
            <span class="k">auto</span> <span class="n">iter1</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
            <span class="k">auto</span> <span class="n">iter2</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">node</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
            <span class="c1">//두 섬이 node 벡터 안에 존재하는지 확인</span>
            
            <span class="k">if</span><span class="p">(</span><span class="n">iter1</span> <span class="o">!=</span> <span class="n">node</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">iter2</span> <span class="o">!=</span> <span class="n">node</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="c1">//두 섬이 모두 존재할 경우</span>
                <span class="k">continue</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iter1</span> <span class="o">!=</span> <span class="n">node</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="c1">//1번 섬이 존재할 경우</span>
                <span class="n">node</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
                <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
                <span class="n">costs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">if</span><span class="p">(</span><span class="n">iter2</span> <span class="o">!=</span> <span class="n">node</span><span class="p">.</span><span class="n">end</span><span class="p">()){</span>
            <span class="c1">//2번 섬이 존재할 경우</span>
                <span class="n">node</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
                <span class="n">answer</span> <span class="o">+=</span> <span class="n">costs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>
                <span class="n">costs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">costs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">answer</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h1 id="후기">후기</h1>
<p>안 풀려서 오랜 시간 머리를 싸맨 문제였다.</p>

<p>아마 다른 풀이들을 참고하지 않았다면 절대로 풀 수 없는 문제였다.</p>

<p>이번 문제의 교훈은 주어진 데이터를 반드시 정렬부터 하고 볼 것이었다.</p>

<p>데이터를 정렬하지 않으면 문제를 어떤 식으로 접근해야 할 지 잘 파악되지 않는다.</p>

<p>일단 정렬부터 해놓으면 좀 더 풀이법에 접근하기가 쉬운 것 같다.</p>

:ET