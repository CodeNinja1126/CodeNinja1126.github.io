---
title: "numpy를 이용한 행렬 연산"
tags: [python]
published: true
---
이번 포스팅에는 edwith 부스트코스 머신러닝을 위한 파이썬 강의에서 다뤘던,

numpy를 이용한 행렬 연산에 대한 내용을 정리한다.

# numpy
numpy를 사용하는 데에는 다음과 같은 이유가 있다.

- 일반 list에 비해 빠르고 메모리 효율적

- 반복문 없이 데이터 배열에 대한 처리를 지원함

- 선형대수와 관련된 다양한 기능을 제공함

- c, c++, 포트란 등의 언어와 통합 가능


일반적으로 다음과 같이 선언해 사용하는 것이 사실상 표준이다.
```python
import numpy as np
```

# ndarray
numpy는 일반적으로 c로 구현되었기 때문에 **데이터 타입을 정적으로 선언**해주어야 한다. 

또한 **한 가지의 데이터 type**만 배열에 넣을 수 있다.

```python
test_array = np.array(['1','2',5,8], float)
```

이와 같이 선언해 ndarray를 생성한다.

일반적으로 머신러닝은 `float64`나 `float32` 데이터 타입을 많이 사용한다.

선언할 때 다른 타입의 자료형을 넣어도 결국엔 선언한 자료형으로 통일되어 저장된다.

## 멤버 변수

- **dtype** : 데이터 타입을 반환

- **shape** : 각 차원 별로 길이를 반환, 이 때 역순으로 높은 차원 부터 낮은 차원 순으로 보여준다.
```python
test_matrix = [[[1, 2],  [3, 4]], [[1, 2],[5, 8]]]
arr = np.array(test_matrix)
arr.shape
# (2, 2, 2)
```
- **ndim** : 차원의 개수를 반환한다.

- **size** : 데이터의 총 길이, shape의 각 요소를 전부 곱한 값이다.

- **T** : transpose 행렬을 반환한다.

# hadling shape

## reshape

데이터의 사이즈는 그대로 shape을 변경하는 것

```python
test_matrix = [[1,2,3,4], [1,2,5,8]]
np.array(test_matrix).reshape(2,2,2)
#[[[1, 2],
#  [3, 4]],
#
# [[1, 2],
#  [5, 8]]]
```

이렇게 선언해 사용한다.

매개 변수를 `-1`로 주면 적절한 값으로 설정된다.

이 때 `-1`로 준 매개 변수는 1개를 넘어선 안된다.

## flatten

다차원 array를 1차원 array로 변환한다.

매개변수 없이 flatten()메소드를 선언해주면 된다.

# Indexing & Slicing

## indexing

arr[1][0]을 arr[1, 0] 과 같이 나타낼 수 있다.

## slicing

list와 달리 행과 열 부분을 나눠서 slicing이 가능하다.

matrix의 부분 집합을 추출할 때 유용하다.

예를 들어, 2차원 shape의 numpy의 경우 다음과 같이 slicing할 수 있다.

```python
test_matrix = [[1,2,3,4], [1,2,5,8], [4,3,2,1]]
arr = np.array(test_matrix)
print(arr[:2, 0:3])
#[[1, 2, 3],
# [1, 2, 5]]
```

# create function

## arange

```python
np.arange(30)
```
이것은 다음 선언과 같다.

```python
np.array([0,1,2, ... , 29])
```

```python
np.arange(0, 5, 0.5)
```

 이렇게 선언할 경우, 첫번째  인자와 두번째 인자는 범위, 세번째 인자는 간격이다. 
 
 당연히 float타입으로 array로 만들어질 것이다.

 arange는 reshape함수와 같이 많이 사용된다.
 
 일반적인 리스트에서는 int 단위로밖에 step이 되지 않는다.
 
 그래서 float단위로 step 리스트를 만들고 싶다면 다음과 같이 선언해주면 된다.

```python
np.arange(1,5,0.5).tolist()
```

## zeros, ones and empty

각각 0,1 비어진 공간만 생성하는 함수, 원형은 다음과 같다.

```python
np.[함수명](shape, dtype, order)
```
empty는 일반적으로 잘 쓰이지 않는다.

### [something]_like

```python
test_matrix = np.arange(30).reshape(5,6)
np.ones_like(test_matrix)
```

이렇게 선언할 경우 test_matrix와 같은 shape의 모든 원소가 1인 array를 생성한다.

## identity

단위 행렬을 생성하는 함수

```python
np.identity(3) #행과 열의 개수를 인수로 받음
```

## eye

대각선이 1인 행렬이다.

대각선의 시작점은 `k`로 받는다.

이 때, `k`값은 음수 값으로도 선언 가능하다.

```python
np.eye(N, M, k, dtype) # N은 row, M은 column, k는 대각선의 시작점
```

`dtype`의 기본 값은 `float`이다.

## diag

대각 요소들로 이루어진 행렬을 추출한다.

```python
np.diag(array, k) ***# k는 역시 대각선의 시작점***
```

## random sampling

데이터 분포에 따른 sampling으로 array를 생성한다.

일단 지금은 일단 알고 있기만 할 것.

```python
np.random.uniform() #균등분포
np.random.normal() #정규분포
```

# calculation

## sum

array의 메소드로 각 요소의 합을 반환한다.

인자로 `dtype`을 받는다.

## axis

array의 모든 operation function을 실행할 때, 기준이 되는 dimension 축이다. 

axis = 0이면 row, axis = 1이면 column이다. 

즉 숫자가 높아질 수록 낮은 차원의 축을 의미한다.

![image1](/images/2020-11-18/1.png)

다음은 sum의 예제이다.

```python
test_array = np.arange(1,13).reshape(3,4)
test_array_1 = test_array.sum(axis = 1)
```
축의 수직을 합을 하는 것이 아니고 축 방향으로 합을 하는 것임을 주의해야 한다.

이 경우 test_array_1은 `array([10, 26, 42])`가 된다.

# concatenate
행렬을 붙이는 메소드

이 메소드들은 속도 면에서 그렇게 빠르지 않다.

따라서 이 기능을 사용하고자 numpy를 사용할 필요는 없다.

## vstack, hstack

numpy array를 수직 및 수평으로 합치는 함수이다.

```python
a = np.array([1,2,3])
b = np.array([2,3,4])
np.vstack((a,b))
```

이럴 경우 `array([[1, 2, 3], [2, 3, 4]])`가 나오게 된다.

```python
a, b = a.reshape(3, 1), b.reshape(3, 1)
np.hstack((a,b))
```

이 경우에는 `array([[1, 2], [2, 3], [3, 4]])`가 나오게 된다.

## concatenate
concatenate는 합칠 방향을 설정할 수 있다.

```python
a = np.array([[1,2,3]])
b = np.array([[2,3,4]])
np.concatenate((a,b),axis = 0)
# [[1, 2, 3],
#  [2, 3, 4]]
```

이 때, 주의해야할 것은 결과값에 차원을 미리 맞춰주어야 한다는 점이다.

`[[1,2,3]]`처럼 2차원의 shape으로 선언해주어야 한다.

그래서 이 경우에는 다음과 같이 reshape과 같은 메소드를 사용해 명시해주는 것이 조금 더 깔끔할 수 있다.
```python
a = np.array([1,2,3]).reshape(1,3)
b = np.array([2,3,4]).reshape(1,3)
np.concatenate((a,b),axis = 1)
```

# Operator

`+`, `-`, `*`는 각 요소합, 요소차, 요소곱이다.

곱은 dot이나 cross product가 아님을 주의해야 한다.

요소곱의 경우에는 같은 shape인지 미리 확인을 해주는 기능이 있다.

## dot product

```python
test_a.dot(test_b)
```

## broadcasting

shape이 다른 배열 간 연산을 지원하는 기능이다.

```python
test_a + 3
```

이 경우에는 test_a에 모든 요소에 3을 더해주게 된다. 

덧셈말고도 `*`, `-`, 심지어는 `>`와 같은 비교 연산도 가능하다.

다음과 같은 형태로 많이 사용한다.
```python
test_a = np.arange(9).reshape(3,3) 
# test_a = [[0,1,2],
#           [3,4,5],
#           [6,7,8]]

test_b = np.arange(3).reshape(1,3)
# test_b = [[0,1,2]]

test_c = test_a + test_b
#test_c =[[ 0,  2,  4],
#         [ 3,  5,  7],
#         [ 6,  8, 10]]
```

이는 밑의 그림과 같은 형태로 덧셈이 이루어진다.

![image1](/images/2020-11-18/2.png)

# where
조건을 만족하는 원소를 찾는 함수이다.

인수의 순서는 c언어의 삼항 연산자를 생각하면 편하다.

```python
test_a = np.arange(3)
np.where(test_a > 1, 3, 2) #각각 조건, 참일 때 값, 거짓일 때 값이다.
# array([2, 2, 3])
```
where에 전달해준 변수에 맞게, 새로운 array를 생성하게 된다. 

하지만 보통은 다음과 같이 사용한다.

```python
np.where(test_a > 1)
# array([2], dtype = ...)
```

이 경우에는 넘겨준 조건에 맞는 원소의 index들의 array를 반환한다.

# argmax & argmin

array내 최대값 또는 최소값의 index를 반환한다.

```python
a = np.array([1,2,4,5,8,78,23,3])
np.argmax(a), np.argmin(a)
# (5,0)
```

다음과 같이 axis기반으로 최대 값, 최소 값을 받을 수도 있다.

```python
a = np.arange(12).reshape(3,4)
np.argmax(a, axis = 1), np.argmin(a, axis = 0)
#(array([3,3,3]),array([0,0,0,0]))
```

# boolean index

ndarray는 인덱스에 조건을 넣을 수도 있다.

```python
a = np.arange(30)
a[a > 15]
# array([16 17 18 19 20 21 22 23 24 25 26 27 28 29])
```
이렇게 조건에 만족하는 원소들로 이루어진 새로운 array를 만들 수 있다.

astype메소드로 다음과 같이 형변환을 할 수도 있다.

```python
a = np.arange(30)
a = a > 15
a.astype(int)
# array([0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 1 1 1])
```

# fancy index

인덱스에 array를 넣어 새로운 array를 추출하는 방법이다.

```python
a = np.array([2, 4, 6, 8], float)
b = np.array([0,0,1,3,2,1], int)
a[b]
# array([2. 2. 4. 8. 6. 4.])
```
이와 같이 b의 각 원소들을 인덱스로 값을 참조해 새로운 array를 생성하게 된다.


하지만 이 경우에는 착각하기 쉽기 때문에 다음과 같이 사용해주면 좋다.

```python
a.take(b)
```

다음과 같이 matrix에서도 사용 가능하다.

```python
a = np.array([[1, 4], [9, 16]], float)
b = np.array([0, 0, 1, 1, 0], int)
c = np.array([0, 1, 1, 1, 1], int)
a[b,c]
# array([  1.,   4.,  16.,  16.,   4.])
```

인덱스로 넣는 array는 반드시 `int` 자료형이어야만 한다.

# loadtxt & savetxt

Text type의 데이터를 읽고, 저장하는 기능이다.

```python
a = np.loadtxt('[파일 명]') # 파일 호출
np.savetxt('[파일 명]', [array 명], delimiter = ',')# 파일 저장
```
