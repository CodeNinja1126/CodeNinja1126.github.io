---
title: "파일 복사 프로그램"
tags: [OS]
published: true
---
# 프로그램 내용
OS공부를 하다 파일을 복사하는 프로그램을 만들라는 과제가 있었다.

요지는 프로그램을 작성하고 그것을 추적 프로그램으로 추적해 시스템 호출을 추적해보라는 것

코드는 몇 줄 안되는데 경험과 지식이 부족하다 보니 문제가 많았다.

그런 문제들을 나름의 해결책과 함께 이야기해보려 한다.
# 문제
## 입력 버퍼 문제
```c
printf("Source file? : ");
scanf("%s",source);

while(getchar() != '\n');
```

처음 c로 코딩을 배우면 `scanf()`이후 개행 문자 처리를 꼭 해주라고 배운다.

`fflush(stdin)`와 같은 방법은 시스템마다 동작이 다르므로 별로 권장되는 방법은 아니다.

보통은 `getchar()`의 버퍼가 비워지는 특성을 이용하여 이 문제를 해결하곤 하더라.

나는 `scanf()`를 사용할 때 메모리의 공간이 부족하면 발생하는 오버플로우가 싫어서 fgets()를 사용하려 했다.

```c
printf("Source file? : ");
fgets(source,100,stdin);

while(getchar() != '\n');
```

이렇게 코드를 쓰면 문자열의 길이가 정해진 값을 넘어갔을 때 생기는 오버플로우 문제는 해결된다.

하지만 `fgets()`는 개행문자를 버퍼에서 읽으면 그대로 남겨두지 않고 버퍼에서 비워버린다.

그래서 오버플로우가 발생하지 않았을 때 `getchar()`이 개행문자를 받지 못해 프로그램 실행시 수동으로 개행 문자를 입력해 주어야 한다.

즉 엔터를 한 번 더 쳐줘야 된다는 얘기다.

`fgets()`는 좋은 해결책이 되지 못했다.

```c
printf("Source file? : ");
scanf("%100s",source);

while(getchar() != '\n');
```

그래서 결국 `scanf()`의 옵션값을 이용해 입력받는 값의 길이를 조정해 주었다.

이렇게 하면 입력값에 의한 오버플로우가 발생하지 않는다. 

또한 문자열의 길이가 길으나 적으나 일관적으로 입력버퍼에 `\n`이 남기 때문에 수동으로 개행문자를 입력해 줄 필요도없다.

`scanf_s()`를 사용하는 방법이 있으나 _s류 함수들은 기본적으로 호환성이 낮아 추천되는 방법은 아니다.

## 실행 파일의 복사
```c
#include <stdio.h>
#include <string.h>

int main(){
  char source[101];
  char target[101];
  //원본과 타겟 파일명
  
  printf("Source file? : ");
  scanf("%100s",source);

  while(getchar() != '\n');
  //파일명 묻기
  
  FILE* sourceFile = fopen(source,"rb");
  //파일 열기
  if(!sourceFile){
    printf("There is no such file.\n");
    return 0;
    //파일이 없으면 종료
  }

  printf("Target file? : ");
  scanf("%100s",target);
  //타겟 파일명 묻기
  
  FILE* targetFile;
  if(fopen(target, "r")){
    printf("That file is aleady exist.\n");
    return 0;
    //파일이 있으면 종료
  }
  targetFile = fopen(target, "wb");
  //타겟 파일 쓰기용으로 열기
  
  unsigned char buffer[1024]; // 버퍼 선언
  int count; // 파일 길이
  
  while(count = fread(buffer,sizeof(char),1024,sourceFile)){ 
    fwrite(buffer,sizeof(char),count,targetFile);
  } 
  //복사
  
  fclose(targetFile);
  fclose(sourceFile);
  //파일들 종료

  return 0;
}
```

위와 같이 코드를 작성하면 파일이 정상적으로 복사된다.

그런데 문제가 하나 있었다.

![screen01](images/2020-10-10/1.png)

텍스트 파일은 정상적으로 복사가 되고 내용도 일치했지만 복사된 실행 파일은 실행이 되지 않았다.

이 문제 때문에 정말 많은 시간을 낭비했다.

원인은 권한 문제였다.

![screen02](images/2020-10-10/2.png)

권한에 쓰기 허용이 되지 않았기 때문이다.

`chmod` 명령어를 이용해 쓰기 권한을 수정해 주었다. (`chmod` 명령어는 나중에 포스팅할 예정이다.)

권한을 설정할 수 있는 코드도 넣을 수 있긴 하지만 호환성 때문에 그대로 놔두었다.

![screen03](images/2020-10-10/3.png)

이후 윈도우 환경에서도 문제없이 적용되는 것을 확인하였다. 

윈도우에서는 `scanf()`명령어가 기본적으로 막혀있으므로 설정을 해주어야 한다.

`_crt_secure_no_warnings`에 대해 구글링하면 대충 해결책이 나올 것이다.

# 시스템 호출 추적

시스템 호출 추적이 사실 주인데 아무래도 주객이 전도된 것 같다.

사실 이 쪽이 더 중요한 내용들인데 아무래도 시간도 없다보니 대충 대충 보고 넘어가야할 것 같다.

![screen05](images/2020-10-10/5.png)

`strace`로 추적한 카피 프로그램의 시스템 호출이다.

윗부분의 내용은 거의 대부분 라이브러리 및 프로그램의 적재에 해당하는 부분인 것 같다.

그리고 빨간색 네모부분이 파일의 복사 부분이다. `read()`와 `write()`가 반복되는 것을 알 수 있다.

그런데 신기한 것이 분명 나는 `char`타입의 1024개의 버퍼를 반복 복사하도록 코드를 작성했는데 복사는 4096바이트씩 되었다.

그리고 읽기와 쓰기의 호출이 내 코드의 순서대로 되지 않았다.

분명히 나는 읽기와 쓰기를 모두 끝낸 후 두 파일을 종료하도록 하였다.

추적을 보면 소스파일이 닫히고도 파일 쓰기가 호출되는 것을 알 수 있다.

혹시나 해서 파일을 닫는 코드의 순서를 바꾸어 보았더니 결과는 아래와 같았다.

![screen04](images/2020-10-10/4.png)

이번에는 확실히 읽기와 쓰기를 끝낸 후 두 파일이 종료되었다.

하지만 쓰기가 두번 연속으로 실행 되는 등, 역시나 내가 의도하던 대로 호출이 되지는 않았다.

아마 컴파일 과정에서 코드를 최적화한 결과일 것이다.

# 후기

정말 별거 없는 프로그램인데 경험의 부족이 뼈져리게 느껴지는 과제였다.

버퍼 문제, 권한 설정 등, 분명히 공부했었다면 쉽게 알 수 있었던 요소들이었다.

시간은 부족하고 할 건 많은데 학교에서 제대로 공부하지 않았던 게 후회가 된다.



